databases:
  augur:
    dsn: !env AUGUR_DSN
    # user: !env AUGUR_DB_USER
    # password: !env AUGUR_DB_PASSWORD


# This query exporter is for fetching values that have no easy way to query them as time series in postgres
# This is because any metric type besides gauge will acumulate values over time. and also prometheus does that... and its a bit of a mess.
# https://github.com/albertodonato/query-exporter/issues/44#issuecomment-639304405
# For queries that are already returning data that is basically ready to graph, maybe doing it in grafana is best
# although large queries might have a performance hit if run too frequently, idk.
metrics:
  augur_collection_status_counts:
    type: gauge
    labels: [collection_state, collection_phase]
    description: Number of repositories in each different state for each phase of collection.
  augur_collection_status_total:
    type: gauge
    description: Number of total repositories in the collection status table, ignoring repos where facade state is Ignore.
  augur_collection_status_full_total:
    type: gauge
    description: Number of total repositories in the collection status table, including ignored values.
  augur_never_collected_counts:
    type: gauge
    labels: [collection_phase]
    description: Number of repositories in each different state for each phase of collection that have never had collection.
  augur_collected_recently_counts:
    type: gauge
    labels: [collection_phase, days_ago]
    description: Number of repositories with last collected dates for each phase of collection across the past 30 days
  augur_14d_counts:
    type: gauge
    labels: [collection_phase]
    description: Total number of repositories with last collected dates for each phase of collection less than 14 days ago
  augur_commits_emails_populated_counts:
    type: gauge
    labels: [column]
    description: Number of total populated (non-null) values in each email addresses column of the commits table.
  augur_contributors_emails_populated_counts:
    type: gauge
    labels: [column]
    description: Number of total populated (non-null) values in each email addresses column of the contributors table.
  augur_rows_by_table_estimate:
    type: gauge
    labels: [schema, table]
    description: Number of total live tuples entries in each table as estimated by pg_stat_user_tables.

queries:
  collection_status_counts:
    interval: 30s
    databases: [augur]
    metrics: [augur_collection_status_counts]
    sql: |
      SELECT
          collection_phase,
          collection_state,
          COALESCE(count, 0) AS augur_collection_status_counts
      FROM (
          SELECT 'core' AS collection_phase, unnest(ARRAY['Pending', 'Error', 'Success', 'Ignore']) AS collection_state
          UNION ALL
          SELECT 'secondary' AS collection_phase, unnest(ARRAY['Pending', 'Error', 'Success', 'Ignore']) AS collection_state
          UNION ALL
          SELECT 'facade' AS collection_phase, unnest(ARRAY['Pending', 'Error', 'Success', 'Ignore']) AS collection_state
      ) AS status_combinations
      LEFT JOIN (
          SELECT
              'core' AS collection_phase, core_status AS collection_state, COUNT(*) as count
          FROM augur_operations.collection_status
          WHERE core_status IN ('Pending', 'Error', 'Success', 'Ignore')
          GROUP BY 1, 2
          UNION ALL
          SELECT
              'secondary' AS collection_phase, secondary_status AS collection_state, COUNT(*) as count
          FROM augur_operations.collection_status
          WHERE secondary_status IN ('Pending', 'Error', 'Success', 'Ignore')
          GROUP BY 1, 2
          UNION ALL
          SELECT
              'facade' AS collection_phase, facade_status AS collection_state, COUNT(*) as count 
          FROM augur_operations.collection_status
          WHERE facade_status IN ('Pending', 'Error', 'Success', 'Ignore')
          GROUP BY 1, 2
      ) AS actual_counts
      USING (collection_phase, collection_state)
      ORDER BY collection_phase, collection_state;
  never_collected_counts:
    interval: 30s
    databases: [augur]
    metrics: [augur_never_collected_counts]
    sql: |
      SELECT
          collection_phase,
          COALESCE(count, 0) AS augur_never_collected_counts
      FROM (
          SELECT 'core' AS collection_phase
          UNION ALL
          SELECT 'secondary' AS collection_phase
          UNION ALL
          SELECT 'facade' AS collection_phase
      ) AS status_combinations
      LEFT JOIN (
          SELECT
              'core' AS collection_phase, COUNT(*) as count
          FROM augur_operations.collection_status
          WHERE core_data_last_collected IS NULL
          UNION ALL
          SELECT
              'secondary' AS collection_phase, COUNT(*) as count
          FROM augur_operations.collection_status
          WHERE secondary_data_last_collected IS NULL
          UNION ALL
          SELECT
              'facade' AS collection_phase, COUNT(*) as count 
          FROM augur_operations.collection_status
          WHERE facade_data_last_collected IS NULL
      ) AS actual_counts
      USING (collection_phase)
      ORDER BY collection_phase;
  total:
    interval: 30s
    databases: [augur]
    metrics: [augur_collection_status_total]
    sql: |
      SELECT
        COUNT(*) AS augur_collection_status_total
      FROM augur_operations.collection_status
      WHERE facade_status != 'Ignore'
  full_total:
    interval: 30s
    databases: [augur]
    metrics: [augur_collection_status_full_total]
    sql: |
      SELECT
        COUNT(*) AS augur_collection_status_full_total
      FROM augur_operations.collection_status
  recency_check:
    interval: 60s
    databases: [augur]
    metrics: [augur_collected_recently_counts]
    sql: |
      select
        'core' as collection_phase,
          EXTRACT(DAY from date_trunc('day', current_date - core_data_last_collected)) AS days_ago,
          COUNT(*) AS augur_collected_recently_counts
      FROM
          augur_operations.collection_status
      WHERE
          core_status != 'Ignore'
      GROUP BY
        days_ago
      UNION all
      select
        'secondary' as collection_phase,
          EXTRACT(DAY from date_trunc('day', current_date - secondary_data_last_collected)) AS days_ago,
          COUNT(*) AS augur_collected_recently_counts
      FROM
          augur_operations.collection_status
      WHERE
          core_status != 'Ignore'
      GROUP BY
        days_ago
      UNION all
      select
        'facade' as collection_phase,
          EXTRACT(DAY from date_trunc('day', current_date - facade_data_last_collected)) AS days_ago,
          COUNT(*) AS augur_collected_recently_counts
      FROM
          augur_operations.collection_status
      WHERE
          core_status != 'Ignore'
      GROUP BY
        days_ago
      ORDER BY
          days_ago;
  recency_14d:
    interval: 60s
    databases: [augur]
    metrics: [augur_14d_counts]
    sql: |
      select
        'core' as collection_phase,
          COUNT(*) AS augur_14d_counts
      FROM
          augur_operations.collection_status
      WHERE core_data_last_collected > (CURRENT_DATE - interval '14 days') AND core_status != 'Ignore'
      UNION all
      select
        'secondary' as collection_phase,
          COUNT(*) AS augur_14d_counts
      FROM
          augur_operations.collection_status
      WHERE secondary_data_last_collected > (CURRENT_DATE - interval '14 days') AND secondary_status != 'Ignore'
      UNION all
      select
        'facade' as collection_phase,
          COUNT(*) AS augur_14d_counts
      FROM
          augur_operations.collection_status
      WHERE facade_data_last_collected > (CURRENT_DATE - interval '14 days') AND facade_status != 'Ignore'
  contributor_email_populated_counts:
    interval: 60s
    databases: [augur]
    metrics: [augur_contributors_emails_populated_counts]
    sql: |
      SELECT 'cntrb_email' AS column, COUNT(c.cntrb_email) as augur_contributors_emails_populated_counts from augur_data.contributors c
      UNION ALL
      SELECT 'cntrb_canonical' AS column, COUNT(c.cntrb_canonical) as augur_contributors_emails_populated_counts from augur_data.contributors c;
  commit_email_populated_counts:
    interval: 60s
    databases: [augur]
    metrics: [augur_commits_emails_populated_counts]
    sql: |
      SELECT 'cmt_author_raw_email' as column, COUNT(c.cmt_author_raw_email) as augur_commits_emails_populated_counts from augur_data.commits c
      UNION ALL
      SELECT 'cmt_author_email' as column, COUNT(c.cmt_author_raw_email) as augur_commits_emails_populated_counts from augur_data.commits c
      UNION ALL
      SELECT 'cmt_committer_raw_email' as column, COUNT(c.cmt_author_raw_email) as augur_commits_emails_populated_counts from augur_data.commits c
      UNION ALL
      SELECT 'cmt_committer_email' as column, COUNT(c.cmt_author_raw_email) as augur_commits_emails_populated_counts from augur_data.commits c;
  # this is the perfectly precise method but takes too much time to run/performance hit
  # row_counts_by_table:
  #   interval: 60s
  #   databases: [augur]
  #   metrics: [augur_contributors_emails_total_counts]
  #   sql: |
  #     SELECT 'contributors' AS column, COUNT(*) as count from augur_data.contributors;
  #     UNION ALL
  #     SELECT 'commits' AS column, COUNT(*) as count from augur_data.contributors c;
  row_count_estimates_by_table:
    interval: 30s
    databases: [augur]
    metrics: [augur_rows_by_table_estimate]
    sql: |
      SELECT 
        schemaname as schema, 
        relname as table, 
        n_live_tup AS augur_rows_by_table_estimate
      FROM pg_stat_user_tables;
